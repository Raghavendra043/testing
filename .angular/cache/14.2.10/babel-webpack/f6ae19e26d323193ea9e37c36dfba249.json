{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let ParserUtilsService = /*#__PURE__*/(() => {\n  class ParserUtilsService {\n    constructor() {\n      this.replaceAll = (str, find, replace) => {\n        const escapeRegExp = str => str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n        return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n      };\n      /**\r\n       * Given a set of node measurement value names (like 'systolic', 'diastolic',\r\n       * and 'pulse' for the 'BloodPressureManualDeviceNode' node type or\r\n       * 'temperature' for 'TemperatureManualDeviceNode') the function then checks\r\n       * whether each of the given values are within the optionally specified input\r\n       * range and if not adds the offending name to the return value.\r\n       */\n      this.measurementsNoRangeCheck = ['mealIndicator'];\n      this.checkInputRanges = (valueNames, node, nodeModel) => valueNames.reduce((acc, nodeTypeName) => {\n        const measurementType = node[nodeTypeName];\n        if (measurementType === undefined && this.measurementsNoRangeCheck.includes(nodeTypeName)) {\n          console.debug(`Skipping range check for: ${nodeTypeName}`);\n          return acc;\n        }\n        if (measurementType === undefined) {\n          console.error(`Unable to find ${nodeTypeName} on current node`);\n          return acc;\n        }\n        const range = measurementType.range;\n        if (range == undefined) {\n          return acc;\n        } else {\n          const min = range.min;\n          const max = range.max;\n          console.debug(`Valid range for \"${nodeTypeName}\": [${min}, ${max}]`);\n          const value = nodeModel[nodeTypeName];\n          if (value === undefined && !0) {\n            console.error(`Value of ${nodeTypeName} is undefined`);\n          } else {\n            console.debug(`${nodeTypeName} value: ${value}`);\n          }\n          const withinRange = min <= value && value <= max;\n          if (!withinRange) {\n            return acc.concat(nodeTypeName);\n          } else {\n            return acc;\n          }\n        }\n      }, []);\n    }\n    getFirstKeyFromLiteral(literal) {\n      for (const key in literal) {\n        if (literal.hasOwnProperty(key)) {\n          return key;\n        }\n      }\n      return undefined;\n    }\n    getNodeTypeName(node) {\n      return this.getFirstKeyFromLiteral(node);\n    }\n    getElementType(element) {\n      return this.getFirstKeyFromLiteral(element);\n    }\n    hashCode(str) {\n      let hash = 0;\n      let chr = 0;\n      if (str.length === 0) {\n        return hash;\n      }\n      for (let i = 0; i < str.length; i++) {\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0; // Convert to 32bit integer\n      }\n\n      return Math.abs(hash);\n    }\n    addManualMeasurementOriginToOutput(outputModel, node) {\n      if (node.origin) {\n        const originName = node.origin.name;\n        const originType = node.origin.type;\n        const originValue = {\n          manualMeasurement: {\n            enteredBy: 'citizen'\n          }\n        };\n        outputModel[originName] = {\n          name: originName,\n          type: originType,\n          value: originValue\n        };\n      }\n    }\n    addMeasurementCommentToOutput(outputModel, nodeModel, node) {\n      var _a;\n      if (node.comment) {\n        const commentName = node.comment.name;\n        const commentType = node.comment.type;\n        const commentValue = (_a = nodeModel.comment) === null || _a === void 0 ? void 0 : _a.text;\n        outputModel[commentName] = {\n          name: commentName,\n          type: commentType,\n          value: commentValue\n        };\n      }\n    }\n    addMeasurementsToOutput(outputModel, nodeModel, node, measurements) {\n      measurements.forEach(measurement => {\n        const measurementName = node[measurement].name;\n        const measurementType = node[measurement].type;\n        const measurementValue = nodeModel[measurement];\n        outputModel[measurementName] = {\n          name: measurementName,\n          type: measurementType,\n          value: measurementValue\n        };\n      });\n    }\n    addHelpMenu(node, representation) {\n      const helpMenu = {\n        text: undefined,\n        image: undefined\n      };\n      if (node.helpText) {\n        helpMenu.text = node.helpText;\n      }\n      if (node.helpImage) {\n        helpMenu.image = node.helpImage;\n      }\n      if (helpMenu.text !== undefined || helpMenu.image !== undefined) {\n        representation.helpMenu = helpMenu;\n      } else {\n        delete representation.helpMenu;\n      }\n    }\n  }\n  ParserUtilsService.ɵfac = function ParserUtilsService_Factory(t) {\n    return new (t || ParserUtilsService)();\n  };\n  ParserUtilsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ParserUtilsService,\n    factory: ParserUtilsService.ɵfac,\n    providedIn: 'root'\n  });\n  return ParserUtilsService;\n})();","map":null,"metadata":{},"sourceType":"module"}
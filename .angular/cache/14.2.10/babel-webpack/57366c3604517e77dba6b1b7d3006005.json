{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let NativeService = /*#__PURE__*/(() => {\n  class NativeService {\n    constructor() {\n      this.subscriptions = {};\n      this.nativeAvailable = false;\n      this.publishMessageFromNative = message => {\n        if (!this.subscriptions.hasOwnProperty(message.messageType)) {\n          console.debug(`No message handlers found to handle message from native layer: ${message.messageType}`);\n        }\n        const handlers = this.subscriptions[message.messageType];\n        const handlersStillRegistered = [];\n        handlers === null || handlers === void 0 ? void 0 : handlers.forEach(handler => {\n          console.debug(`invoking handler for messageType: ${message.messageType}`);\n          if (handler.autoUnregister === true) {\n            handler.handleMessage(message);\n          } else {\n            handler.handleMessage(message);\n            handlersStillRegistered.push(handler);\n          }\n        });\n        this.subscriptions[message.messageType] = handlersStillRegistered;\n      };\n      this.enableMessagesFromNative = () => {\n        const sendMessageToWebView = rawMessage => {\n          console.debug(`message from native layer received: ${rawMessage}`);\n          const parsedMessage = JSON.parse(rawMessage);\n          this.publishMessageFromNative(parsedMessage);\n        };\n        globalThis.sendMessageToWebView = sendMessageToWebView;\n      };\n      this.removeSecretFields = message => {\n        const clone = JSON.parse(JSON.stringify(message));\n        delete clone.credentials;\n        return clone;\n      };\n      this.sendMessageToNative = message => {\n        var _a, _b, _c, _d;\n        const msgAsString = JSON.stringify(message);\n        const messageToLog = this.removeSecretFields(message);\n        console.debug(\"Sending message to native layer: \" + JSON.stringify(messageToLog));\n        if ((_a = globalThis.external) === null || _a === void 0 ? void 0 : _a.notify) {\n          globalThis.external.notify(msgAsString);\n          return true;\n        } else if (((_d = (_c = (_b = globalThis.webkit) === null || _b === void 0 ? void 0 : _b.messageHandlers) === null || _c === void 0 ? void 0 : _c.notify) === null || _d === void 0 ? void 0 : _d.postMessage) !== undefined) {\n          globalThis.webkit.messageHandlers.notify.postMessage(msgAsString);\n          return true;\n        } else {\n          console.debug(\"Couldnt' deliver message to native layer\");\n          return false;\n        }\n      };\n      this.addSubscription = (messageType, callback, autoUnregister) => {\n        if (!this.subscriptions.hasOwnProperty(messageType)) {\n          this.subscriptions[messageType] = [];\n        }\n        const callbackTag = this.calculateCallbackTag(callback);\n        if (this.notAlreadySubscribed(this.subscriptions[messageType], callbackTag)) {\n          console.debug(`Subscribing to ${messageType}`);\n          this.subscriptions[messageType].push({\n            handleMessage: callback,\n            autoUnregister: autoUnregister,\n            callbackTag: callbackTag\n          });\n        } else {\n          console.debug(\"Provided callback already subscribed to \" + messageType);\n        }\n      };\n      this.calculateCallbackTag = callback => {\n        const asStr = callback.toString();\n        let tag = 0;\n        for (let i = 0; i < asStr.length; i++) {\n          tag = Math.imul(31, tag) + asStr.charCodeAt(i) | 0;\n        }\n        console.debug(`Subscription callback tag: ${tag}`);\n        return tag;\n      };\n      this.notAlreadySubscribed = (subscribers, callbackTag) => {\n        return !subscribers.some(s => s.callbackTag === callbackTag);\n      };\n      this.subscribeToSingleMessage = (messageType, callback) => {\n        this.addSubscription(messageType, callback, true);\n      };\n      this.subscribeToMultipleMessages = (messageType, callback) => {\n        this.addSubscription(messageType, callback, false);\n      };\n      this.unsubscribe = (messageType, callback) => {\n        if (this.subscriptions.hasOwnProperty(messageType)) {\n          const remainingSubscriptions = [];\n          this.subscriptions[messageType].forEach(handler => {\n            if (handler.handleMessage !== callback) {\n              remainingSubscriptions.push(handler);\n            }\n          });\n          this.subscriptions[messageType] = remainingSubscriptions;\n        }\n      };\n      this.unsubscribeAll = messageType => {\n        if (this.subscriptions.hasOwnProperty(messageType)) {\n          this.subscriptions[messageType] = [];\n        }\n      };\n      /**\r\n       * Tries to open a URL first by asking the native layer and if it doesn't\r\n       * exist, then directly by the browser.\r\n       */\n      this.openUrl = url => {\n        const request = {\n          messageType: \"openUrlRequest\",\n          url: url\n        };\n        const handledByNative = this.sendMessageToNative(request);\n        if (!handledByNative) {\n          globalThis.open(url);\n        }\n      };\n      this.enableClientLogging = callback => {\n        this.subscribeToMultipleMessages(\"logMessagesReady\", callback);\n        const request = {\n          messageType: \"clientLoggingEnabled\"\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.getDeviceToken = callback => {\n        this.subscribeToMultipleMessages(\"deviceTokenResponse\", callback);\n        const request = {\n          messageType: \"deviceTokenRequest\"\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.clearScheduledQuestionnaire = questionnaireId => {\n        const request = {\n          messageType: \"clearScheduledQuestionnaireRequest\",\n          questionnaireId: questionnaireId\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.updateScheduledQuestionnaires = scheduledQuestionnaires => {\n        const request = {\n          messageType: \"updateScheduledQuestionnairesRequest\",\n          scheduledQuestionnaires: scheduledQuestionnaires\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.clearUnreadMessages = () => {\n        const request = {\n          messageType: \"clearUnreadMessagesRequest\"\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.clientIsVideoEnabled = callback => {\n        this.subscribeToSingleMessage(\"videoEnabledResponse\", callback);\n        const request = {\n          messageType: \"videoEnabledRequest\"\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.joinConference = videoConferenceDescription => {\n        const request = {\n          messageType: \"startVideoConferenceRequest\",\n          videoConference: videoConferenceDescription\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.leaveConference = () => {\n        const request = {\n          messageType: \"stopVideoConferenceRequest\"\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.playNotificationSound = () => {\n        const request = {\n          messageType: \"startNotificationSoundRequest\"\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.stopNotificationSound = () => {\n        const request = {\n          messageType: \"stopNotificationSoundRequest\"\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.addDeviceListener = (meterType, parameters) => {\n        const request = {\n          messageType: \"deviceMeasurementRequest\",\n          meterType: meterType,\n          parameters: parameters\n        };\n        return this.sendMessageToNative(request);\n      };\n      this.removeDeviceListeners = () => {\n        const request = {\n          messageType: \"stopDeviceMeasurementRequest\"\n        };\n        this.unsubscribeAll(\"deviceMeasurementResponse\");\n        return this.sendMessageToNative(request);\n      };\n      this.showConfirmDialog = (text, okButtonText, cancelButtonText, onClosed) => {\n        this.subscribeToSingleMessage(\"showPopupDialogResponse\", resp => onClosed(resp.result));\n        const request = {\n          messageType: \"showPopupDialogRequest\",\n          text: text,\n          showCancelButton: true,\n          okButtonText: okButtonText,\n          cancelButtonText: cancelButtonText\n        };\n        const handledByNative = this.sendMessageToNative(request);\n        if (!handledByNative) {\n          const result = globalThis.confirm(text);\n          onClosed(result);\n        }\n      };\n      this.showAlertDialog = (text, okButtonText, onClosed) => {\n        this.subscribeToSingleMessage(\"showPopupDialogResponse\", onClosed);\n        const request = {\n          messageType: \"showPopupDialogRequest\",\n          text: text,\n          showCancelButton: false,\n          okButtonText: okButtonText\n        };\n        const handledByNative = this.sendMessageToNative(request);\n        if (!handledByNative) {\n          globalThis.alert(text);\n          onClosed();\n        }\n      };\n    }\n    isAvailable() {\n      var _a, _b, _c, _d;\n      //@ts-ignore\n      if ((_a = globalThis.external) === null || _a === void 0 ? void 0 : _a.notify) {\n        return true;\n      } else if (((_d = (_c = (_b = globalThis.webkit) === null || _b === void 0 ? void 0 : _b.messageHandlers) === null || _c === void 0 ? void 0 : _c.notify) === null || _d === void 0 ? void 0 : _d.postMessage) !== undefined) {\n        return true;\n      } else {\n        console.debug(\"No native layer found\");\n        return false;\n      }\n    }\n  }\n  NativeService.ɵfac = function NativeService_Factory(t) {\n    return new (t || NativeService)();\n  };\n  NativeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NativeService,\n    factory: NativeService.ɵfac,\n    providedIn: \"root\"\n  });\n  return NativeService;\n})();","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Validators } from \"@angular/forms\";\nimport { ComponentParameters } from \"src/app/types/nodes.type\";\nimport { ButtonElement, EditTextElement, HelpNode, HelpTextElement, IONode, NodeElement, NodeElementWrapper, NodeMap, OriginElement, Representation, NodeRepresentation, TextViewElement, TwoButtonElement, RepresentationType } from \"src/app/types/parser.type\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/forms\";\nimport * as i2 from \"src/app/services/parser-services/parser-utils.service\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"src/app/directives/focus-on-load.directive\";\nimport * as i5 from \"src/app/pipes/safe.pipe\";\nfunction IONodeComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵelement(1, \"h2\", 5);\n    i0.ɵɵpipe(2, \"safe\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const label_r3 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"innerHtml\", i0.ɵɵpipeBind2(2, 1, label_r3, \"html\"), i0.ɵɵsanitizeHtml);\n  }\n}\nfunction IONodeComponent_fieldset_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"fieldset\", 6)(1, \"div\", 7)(2, \"label\", 8);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(4, \"textarea\", 9);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const textInput_r5 = ctx.$implicit;\n    const i_r6 = ctx.index;\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", textInput_r5.name);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(textInput_r5.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"formControlName\", i_r6);\n  }\n}\nfunction IONodeComponent_fieldset_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"fieldset\", 10)(1, \"div\", 7)(2, \"label\", 11);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(4, \"input\", 12);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const input_r7 = ctx.$implicit;\n    const i_r8 = ctx.index;\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", input_r7.name);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(input_r7 == null ? null : input_r7.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", input_r7 == null ? null : input_r7.name)(\"name\", input_r7 == null ? null : input_r7.name)(\"formControlName\", i_r8)(\"type\", input_r7 == null ? null : input_r7.type)(\"step\", input_r7 == null ? null : input_r7.step);\n  }\n}\nexport let IONodeComponent = /*#__PURE__*/(() => {\n  class IONodeComponent {\n    constructor(formBuilder, parserUtils) {\n      this.formBuilder = formBuilder;\n      this.parserUtils = parserUtils;\n      // Form\n      this.textInputs = [];\n      this.inputs = [];\n      this.nodeForm = this.formBuilder.group({\n        textInputControls: this.formBuilder.array([]),\n        inputControls: this.formBuilder.array([])\n      });\n      // Properties\n      this.labels = [];\n      this.clickActions = [];\n      this.validateActions = [];\n      this.callHandler = (elementName, element, representation) => {\n        switch (elementName) {\n          case \"TextViewElement\":\n            this.handleTextViewElement(element);\n            break;\n          case \"OriginElement\":\n            this.handleOriginElement(element);\n            break;\n          case \"EditTextElement\":\n            this.handleEditTextElement(element);\n            break;\n          case \"ButtonElement\":\n            this.handleButtonElement(element, representation);\n            break;\n          case \"TwoButtonElement\":\n            this.handleTwoButtonElement(element, representation);\n            break;\n          case \"HelpTextElement\":\n            this.handleHelpTextElement(element, representation);\n            break;\n          default:\n            console.error(`Unable to call handler for element type: ${elementName} for IONode`);\n            break;\n        }\n      };\n      this.handleTextViewElement = element => {\n        return this.labels.push(element.text);\n      };\n      this.handleOriginElement = element => {\n        this.clickActions.push(scope => {\n          const originType = element.outputVariable.type;\n          const originName = element.outputVariable.name;\n          const originValue = {\n            manualMeasurement: {\n              enteredBy: \"citizen\"\n            }\n          };\n          scope.outputModel[originName] = {\n            name: originName,\n            type: originType,\n            value: originValue\n          };\n        });\n      };\n      this.handleEditTextElement = element => {\n        var _a;\n        const rawElementType = element.outputVariable.type;\n        if (![\"String\", \"Integer\", \"Float\"].includes(rawElementType)) {\n          throw new Error(\"Unexpected element type for EditTextElement: \" + rawElementType);\n        }\n        const elementType = rawElementType === \"String\" ? \"text\" : \"number\";\n        const fieldName = `input_${elementType}_${this.parserUtils.hashCode(element.outputVariable.name)}`;\n        const formPattern = rawElementType === \"String\" ? /.*/ : /(\\d*[.,])?\\d+/;\n        const formStep = rawElementType === \"Integer\" ? \"1\" : \"any\";\n        let validators;\n        if (rawElementType === \"String\") {\n          validators = [Validators.required, Validators.minLength(1), Validators.maxLength(1800)];\n        } else if (rawElementType === \"Integer\") {\n          validators = [Validators.required, this.isInteger];\n        } else {\n          validators = [Validators.required, Validators.pattern(formPattern)];\n        }\n        const editTextFormControl = {\n          name: fieldName,\n          type: elementType,\n          pattern: formPattern,\n          step: formStep,\n          label: (_a = this.labels.pop()) !== null && _a !== void 0 ? _a : \"\"\n        };\n        if (elementType === \"text\") {\n          //'ioNodeTextInput.html'\n          this.textInputs.push(editTextFormControl);\n          this.textInputControls.push(this.formBuilder.control(\"\", validators));\n        } else {\n          //'ioNodeInput.html'\n          this.inputs.push(editTextFormControl);\n          this.inputControls.push(this.formBuilder.control(\"\", validators));\n        }\n        this.clickActions.push(scope => {\n          const variableName = element.outputVariable.name;\n          let value = undefined;\n          if (elementType === \"text\") {\n            const index = this.textInputs.findIndex(({\n              name\n            }) => {\n              return name === fieldName;\n            });\n            if (index >= 0) {\n              value = this.textInputControls.at(index).value;\n            }\n          } else {\n            const index = this.inputs.findIndex(object => {\n              return object.name === fieldName;\n            });\n            if (index >= 0) {\n              value = this.inputControls.at(index).value;\n            }\n          }\n          if (value) {\n            scope.outputModel[variableName] = {\n              name: variableName,\n              value: value,\n              type: rawElementType\n            };\n          } else {\n            console.error(`Variabel in output model for name: '${variableName}', type: ${rawElementType} was undefined`);\n          }\n        });\n        this.validateActions.push(scope => !this.nodeForm.invalid);\n      };\n      this.handleButtonElement = (element, representation) => {\n        const buttonRepresentation = {\n          show: true,\n          text: element.text,\n          nextNodeId: element.next\n        };\n        this.setupClickActions(element.skipValidation, buttonRepresentation);\n        switch (element.gravity) {\n          case \"center\":\n            representation.centerButton = buttonRepresentation;\n            break;\n          case \"right\":\n            representation.rightButton = buttonRepresentation;\n            break;\n          case \"left\":\n            representation.leftButton = buttonRepresentation;\n            break;\n        }\n      };\n    }\n    getRepresentation() {\n      const representation = {\n        kind: RepresentationType.NODE,\n        nodeModel: {\n          nodeId: this.node.nodeName\n        }\n      };\n      this.node.elements.forEach(elementWrapper => {\n        const elementName = this.parserUtils.getElementType(elementWrapper);\n        this.callHandler(elementName, elementWrapper[elementName], representation);\n      });\n      return representation;\n    }\n    handleTwoButtonElement(element, representation) {\n      var _a, _b;\n      const leftButton = {\n        show: true,\n        text: element.leftText,\n        nextNodeId: element.leftNext\n      };\n      this.setupClickActions((_a = element.leftSkipValidation) !== null && _a !== void 0 ? _a : false, leftButton);\n      representation.leftButton = leftButton;\n      const rightButton = {\n        show: true,\n        text: element.rightText,\n        nextNodeId: element.rightNext\n      };\n      this.setupClickActions((_b = element.rightSkipValidation) !== null && _b !== void 0 ? _b : false, rightButton);\n      representation.rightButton = rightButton;\n    }\n    setupClickActions(skipValidation, buttonRepresentation) {\n      if (skipValidation) {\n        return;\n      }\n      buttonRepresentation.click = scope => {\n        for (let i = 0; i < this.clickActions.length; i++) {\n          this.clickActions[i](scope);\n        }\n      };\n      buttonRepresentation.validate = scope => {\n        for (let i = 0; i < this.validateActions.length; i++) {\n          if (this.validateActions[i](scope) === false) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n    handleHelpTextElement(element, representation) {\n      if (typeof element === \"undefined\" || element === null) {\n        return;\n      }\n      const helpNode = {\n        nodeName: \"\",\n        next: \"\",\n        nextFail: \"\",\n        text: \"\"\n      };\n      if (element.text) {\n        helpNode.helpText = element.text;\n      }\n      if (element.image) {\n        helpNode.helpImage = element.image;\n      }\n      this.parserUtils.addHelpMenu(helpNode, representation);\n    }\n    onSubmit() {\n      console.log(this.nodeForm.value);\n    }\n    get textInputControls() {\n      return this.nodeForm.get(\"textInputControls\");\n    }\n    get inputControls() {\n      return this.nodeForm.get(\"inputControls\");\n    }\n    isInteger(control) {\n      const value = control.value === \"\" ? undefined : Number(control.value);\n      if (Number.isInteger(value)) {\n        console.debug(\"is Actually an integer\");\n        return null;\n      } else {\n        console.debug(\"is Actually not an integer\");\n        return {\n          must_be_integer: `${value} is not an Integer`\n        };\n      }\n    }\n  }\n  IONodeComponent.ɵfac = function IONodeComponent_Factory(t) {\n    return new (t || IONodeComponent)(i0.ɵɵdirectiveInject(i1.NonNullableFormBuilder), i0.ɵɵdirectiveInject(i2.ParserUtilsService));\n  };\n  IONodeComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: IONodeComponent,\n    selectors: [[\"app-ionode\"]],\n    inputs: {\n      node: \"node\",\n      nodeMap: \"nodeMap\",\n      scope: \"scope\",\n      parameters: \"parameters\"\n    },\n    decls: 4,\n    vars: 4,\n    consts: [[3, \"formGroup\", \"ngSubmit\"], [\"class\", \"center-div\", 4, \"ngFor\", \"ngForOf\"], [\"formArrayName\", \"textInputControls\", \"class\", \"questionnaire-fields\", 4, \"ngFor\", \"ngForOf\"], [\"formArrayName\", \"inputControls\", \"class\", \"questionnaire-fields\", 4, \"ngFor\", \"ngForOf\"], [1, \"center-div\"], [1, \"line-wrap\", \"text-element\", 3, \"innerHtml\"], [\"formArrayName\", \"textInputControls\", 1, \"questionnaire-fields\"], [1, \"block\"], [2, \"display\", \"block\", 3, \"for\"], [\"id\", \"textInput.name\", \"name\", \"textInput.name\", \"rows\", \"8\", \"autocomplete\", \"off\", \"maxlength\", \"1800\", \"type\", \"textInput.type\", \"focusOnLoad\", \"\", 2, \"display\", \"block\", 3, \"formControlName\"], [\"formArrayName\", \"inputControls\", 1, \"questionnaire-fields\"], [3, \"for\"], [\"autocomplete\", \"off\", \"focusOnLoad\", \"\", 3, \"id\", \"name\", \"formControlName\", \"type\", \"step\"]],\n    template: function IONodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"form\", 0);\n        i0.ɵɵlistener(\"ngSubmit\", function IONodeComponent_Template_form_ngSubmit_0_listener() {\n          return ctx.onSubmit();\n        });\n        i0.ɵɵtemplate(1, IONodeComponent_div_1_Template, 3, 4, \"div\", 1);\n        i0.ɵɵtemplate(2, IONodeComponent_fieldset_2_Template, 5, 3, \"fieldset\", 2);\n        i0.ɵɵtemplate(3, IONodeComponent_fieldset_3_Template, 5, 7, \"fieldset\", 3);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"formGroup\", ctx.nodeForm);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.labels);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.textInputs);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.inputs);\n      }\n    },\n    dependencies: [i3.NgForOf, i1.ɵNgNoValidate, i1.DefaultValueAccessor, i1.NgControlStatus, i1.NgControlStatusGroup, i1.MaxLengthValidator, i1.FormGroupDirective, i1.FormControlName, i1.FormArrayName, i4.FocusOnLoadDirective, i5.SafePipe]\n  });\n  return IONodeComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}
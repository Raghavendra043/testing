{"ast":null,"code":"import { ComponentParameters } from 'src/app/types/nodes.type';\nimport { RepresentationType, DecisionValueType } from 'src/app/types/parser.type';\nimport * as i0 from \"@angular/core\";\nvar Operator = /*#__PURE__*/(() => {\n  (function (Operator) {\n    Operator[\"LESS_THAN\"] = \"lt\";\n    Operator[\"GREATER_THAN\"] = \"gt\";\n    Operator[\"EQUAL\"] = \"eq\";\n  })(Operator || (Operator = {}));\n  return Operator;\n})();\nexport let DecisionNodeComponent = /*#__PURE__*/(() => {\n  class DecisionNodeComponent {\n    constructor() {\n      this.getOperator = node => {\n        for (var candidate in node.expression) {\n          switch (candidate) {\n            case 'lt':\n              return Operator.LESS_THAN;\n            case 'gt':\n              return Operator.GREATER_THAN;\n            case 'eq':\n              return Operator.EQUAL;\n            default:\n              throw new Error(`Unsupported operator: ${candidate}`);\n          }\n        }\n        throw new Error('Empty DecisionNode');\n      };\n      this.getValueAndType = (side, outputModel) => {\n        if (side.type === DecisionValueType.NAME) {\n          const actualValue = outputModel[side.value].value;\n          const actualType = outputModel[side.value].type;\n          return {\n            value: actualValue,\n            type: actualType\n          };\n        } else {\n          return {\n            value: side.value,\n            type: side.type\n          };\n        }\n      };\n      this.evaluate = (operator, left, right) => {\n        if (left.type !== right.type) {\n          throw new TypeError('Type for left and right side must be the same. Left: ' + left.type + ', right: ' + right.type);\n        }\n        switch (operator) {\n          case Operator.LESS_THAN:\n            if (left.type === DecisionValueType.BOOLEAN) {\n              throw new TypeError('Boolean expression with operators other than eq not supported.');\n            }\n            return left.value < right.value;\n          case Operator.GREATER_THAN:\n            if (left.type === DecisionValueType.BOOLEAN) {\n              throw new TypeError('Boolean expression with operators other than eq not supported.');\n            }\n            return left.value > right.value;\n          case Operator.EQUAL:\n            return left.value === right.value;\n        }\n      };\n    }\n    getRepresentation() {\n      const operator = this.getOperator(this.node);\n      const outputModel = this.scope.outputModel;\n      const comparison = this.node.expression[operator];\n      if (comparison === undefined) {\n        throw new Error('Empty DecisionNode');\n      }\n      const left = this.getValueAndType(comparison.left, outputModel);\n      const right = this.getValueAndType(comparison.right, outputModel);\n      const evaluation = this.evaluate(operator, left, right);\n      const nextNodeId = evaluation ? this.node.next : this.node.nextFalse;\n      return {\n        kind: RepresentationType.SKIP,\n        nodeModel: {\n          nodeId: this.node.nodeName\n        },\n        nextNodeId: nextNodeId\n      };\n    }\n  }\n  DecisionNodeComponent.ɵfac = function DecisionNodeComponent_Factory(t) {\n    return new (t || DecisionNodeComponent)();\n  };\n  DecisionNodeComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: DecisionNodeComponent,\n    selectors: [[\"app-decision-node\"]],\n    inputs: {\n      node: \"node\",\n      nodeMap: \"nodeMap\",\n      scope: \"scope\",\n      parameters: \"parameters\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function DecisionNodeComponent_Template(rf, ctx) {}\n  });\n  return DecisionNodeComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}
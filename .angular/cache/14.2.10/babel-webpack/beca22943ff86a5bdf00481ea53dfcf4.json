{"ast":null,"code":"import { DelayNode, DelayNodeModel, NodeMap, NodeParserFunction, NodeRepresentation, RepresentationType } from 'src/app/types/parser.type';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../timer/timer.component\";\nexport let DelayNodeComponent = /*#__PURE__*/(() => {\n  class DelayNodeComponent {\n    onTimerStopped() {\n      this.scope.nextNode(this.node.next, this.nodeMap);\n    }\n    getRepresentation() {\n      const parseNode = (node, _nodeMap, _outputModel) => {\n        this.nodeModel = {\n          nodeId: node.nodeName,\n          heading: node.displayTextString,\n          count: node.countUp ? 0 : node.countTime,\n          countTime: node.countTime,\n          countUp: node.countUp,\n          onTimerStopped: this.onTimerStopped\n        };\n        const centerButton = {\n          show: true,\n          text: 'NEXT',\n          validate: () => false\n        };\n        const representation = {\n          kind: RepresentationType.NODE,\n          nodeModel: this.nodeModel,\n          centerButton: centerButton\n        };\n        return representation;\n      };\n      return parseNode(this.node, this.nodeMap, this.scope.outputModel);\n    }\n  }\n  DelayNodeComponent.ɵfac = function DelayNodeComponent_Factory(t) {\n    return new (t || DelayNodeComponent)();\n  };\n  DelayNodeComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: DelayNodeComponent,\n    selectors: [[\"app-delay-node\"]],\n    inputs: {\n      node: \"node\",\n      nodeMap: \"nodeMap\",\n      scope: \"scope\",\n      parameters: \"parameters\"\n    },\n    decls: 4,\n    vars: 4,\n    consts: [[1, \"center-div\"], [1, \"line-wrap\", \"text-element\"], [3, \"count\", \"countUp\", \"countTime\", \"timerStoppedChange\"]],\n    template: function DelayNodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"h2\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(3, \"timer\", 2);\n        i0.ɵɵlistener(\"timerStoppedChange\", function DelayNodeComponent_Template_timer_timerStoppedChange_3_listener() {\n          return ctx.onTimerStopped();\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.nodeModel == null ? null : ctx.nodeModel.heading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"count\", ctx.nodeModel == null ? null : ctx.nodeModel.count)(\"countUp\", ctx.nodeModel == null ? null : ctx.nodeModel.countUp)(\"countTime\", ctx.nodeModel == null ? null : ctx.nodeModel.countTime);\n      }\n    },\n    dependencies: [i1.TimerComponent]\n  });\n  return DelayNodeComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}
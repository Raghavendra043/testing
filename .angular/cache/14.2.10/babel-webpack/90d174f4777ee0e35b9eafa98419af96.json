{"ast":null,"code":"import _asyncToGenerator from \"D:/Users/raghavendra/Desktop/ODE/OPTH/New folder/testing/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpClient, HttpContext } from \"@angular/common/http\";\nimport { ERROR_PASS_THROUGH, SILENT_REQUEST } from \"@app/interceptors/interceptor\";\nimport { lastValueFrom } from \"rxjs\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app/services/native-services/native.service\";\nimport * as i2 from \"src/app/services/util-services/util.service\";\nimport * as i3 from \"@angular/common/http\";\nexport let NotificationsService = /*#__PURE__*/(() => {\n  class NotificationsService {\n    constructor(native, util, http) {\n      var _this = this;\n      this.native = native;\n      this.util = util;\n      this.http = http;\n      /**\r\n       * Clears state about user having registered for push notifications.\r\n       */\n      this.clearPushNotificationRegistrationState = () => {\n        this.registrationPromise = undefined;\n      };\n      /**\r\n       * Tries to register a user's device for push notifications.\r\n       */\n      this.registerDeviceForPushNotifications = user => {\n        const registrationPromise = new Promise((accept, reject) => {\n          const deviceTokenRequested = this.native.getDeviceToken(({\n            deviceToken,\n            deviceOS\n          }) => this.registerDevice(user, deviceToken, deviceOS).then(() => {\n            console.debug(`Device with token: '${deviceToken}' successfully registered for push notifications`);\n            accept();\n          }).catch(() => {\n            console.error(`Failed to register device token: ${deviceToken} for push notifications`);\n          }));\n          if (!deviceTokenRequested) {\n            console.debug(\"Couldn't request device token\");\n          }\n        });\n        return registrationPromise;\n      };\n      /**\r\n       * Registers a device for push notifications if it was not, and returns (in a promise)\r\n       * a boolean indicading whether the registration has succeeded or not.\r\n       */\n      this.ensureDeviceRegisteredForPushNotifications = user => {\n        if (!this.registrationPromise) {\n          return this.registerDeviceForPushNotifications(user);\n        }\n        return this.registrationPromise.then(() => true, () => false);\n      };\n      /**\r\n       * Tries to register a user's device for push notifications.\r\n       */\n      this.registerDevice = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (user, deviceToken, deviceOS) {\n          var _a, _b;\n          if (!_this.util.exists((_a = user.links) === null || _a === void 0 ? void 0 : _a.notifications) || !_this.util.exists((_b = user.links) === null || _b === void 0 ? void 0 : _b.self)) {\n            throw new TypeError(\"User object is missing a link to either 'patient' or 'notifications'\");\n          }\n          const context = new HttpContext().set(ERROR_PASS_THROUGH, true).set(SILENT_REQUEST, true);\n          const patientUrl = user.links.self;\n          const devicesUrl = user.links.notifications;\n          const searchUrl = devicesUrl + \"?patientUrl=\" + patientUrl;\n          const response = yield lastValueFrom(_this.http.get(searchUrl, {\n            context\n          }));\n          const device = response.results.find(({\n            patientUrl: url\n          }) => url === patientUrl);\n          if (_this.util.exists(device) && _this.util.exists(device.links) && _this.util.exists(device.links.device)) {\n            const devicePayload = {\n              patientUrl: device.patientUrl,\n              deviceToken: deviceToken,\n              deviceOS: deviceOS\n            };\n            // Update existing\n            return lastValueFrom(_this.http.put(device.links.device, devicePayload, {\n              context\n            }));\n          } else {\n            // Register new\n            return lastValueFrom(_this.http.post(devicesUrl, {\n              patientUrl,\n              deviceToken,\n              deviceOS\n            }));\n          }\n        });\n        return function (_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n  }\n  NotificationsService.ɵfac = function NotificationsService_Factory(t) {\n    return new (t || NotificationsService)(i0.ɵɵinject(i1.NativeService), i0.ɵɵinject(i2.Utils), i0.ɵɵinject(i3.HttpClient));\n  };\n  NotificationsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NotificationsService,\n    factory: NotificationsService.ɵfac,\n    providedIn: \"root\"\n  });\n  return NotificationsService;\n})();","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { HttpContext, HttpErrorResponse, HttpHeaders } from '@angular/common/http';\nimport { ERROR_PASS_THROUGH } from '@app/interceptors/interceptor';\nimport { JwtHelperService } from '@auth0/angular-jwt';\nimport { AUTO_LOGIN_TOKEN, BYPASS_CUSTOM_CLAIMS_KEY, BYPASS_TOKEN_KEY, CAN_CHANGE_PASSWORD, REFRESH_TOKEN, REMEMBER_ME } from '@utils/globals';\nimport { lastValueFrom, map, of, tap, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@services/state-services/state-passing.service\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"@services/util-services/util.service\";\nexport let AuthenticationService = /*#__PURE__*/(() => {\n  class AuthenticationService {\n    constructor(appContext, http, utils) {\n      this.appContext = appContext;\n      this.http = http;\n      this.utils = utils;\n      this.jwtHelper = new JwtHelperService();\n      this.updateStoredAuthDetails = authResponse => {\n        this.updateRefreshToken(authResponse.refreshToken);\n        this.defaultAuthHeader(authResponse.type + ' ' + authResponse.token);\n      };\n      this.updateRefreshToken = refreshToken => {\n        var _a;\n        if ((_a = REMEMBER_ME.get()) !== null && _a !== void 0 ? _a : false) {\n          AUTO_LOGIN_TOKEN.set(refreshToken);\n        } else {\n          REFRESH_TOKEN.set(refreshToken);\n        }\n      };\n      this.isBypassingLoginScreen = () => {\n        return BYPASS_TOKEN_KEY.get() !== null;\n      };\n      this.getBypassCredentials = () => {\n        const token = BYPASS_TOKEN_KEY.get();\n        if (token === null) {\n          console.error('Auth token not set in session storage');\n          throw new Error('Auth token not set in session storage');\n        }\n        const customClaims = BYPASS_CUSTOM_CLAIMS_KEY.get();\n        if (customClaims === null) {\n          console.error('Custom claims not set in session storage');\n          throw new Error('Custom claims not set in session storage');\n        }\n        return {\n          token: token,\n          //@ts-ignore\n          customClaims: customClaims\n        };\n      };\n      this.defaultAuthHeader = authHeader => {\n        this.appContext.requestParams.set('authorizationHeader', authHeader);\n      };\n      this.patientAuthHeader = authHeader => {\n        this.appContext.requestParams.set('patientAuthorizationHeader', authHeader);\n      };\n    }\n    login(authUrl, credentials, rememberMe, customHeaders = {}) {\n      REMEMBER_ME.set(rememberMe);\n      const options = {\n        context: new HttpContext().set(ERROR_PASS_THROUGH, true),\n        withCredentials: true,\n        headers: new HttpHeaders(Object.assign(Object.assign({}, this.buildAuthHeader(credentials)), customHeaders))\n      };\n      return this.http.get(authUrl, options).pipe(tap(response => this.updateStoredAuthDetails(response)), map(response => ({\n        claims: this.jwtHelper.decodeToken(response.token),\n        organizations: response.customClaims.organizations,\n        canChangePassword: CAN_CHANGE_PASSWORD.get(true),\n        logoutUrl: response.links.logout\n      })), catchError(err => {\n        if (err instanceof HttpErrorResponse) {\n          return of(this.wrapError(err));\n        } else throw err;\n      }));\n    }\n    trySilentLogin(authUrl, customHeaders = {}) {\n      if (this.isBypassingLoginScreen()) {\n        const bypassCredentials = this.getBypassCredentials();\n        this.defaultAuthHeader('Bearer ' + bypassCredentials.token);\n        return of(this.createCredentials(bypassCredentials.token, bypassCredentials.customClaims, false, undefined));\n      }\n      const refreshToken = this.tryGetRefreshToken();\n      if (refreshToken !== null) {\n        const credentials = {\n          token: refreshToken,\n          type: 'Refresh'\n        };\n        return this.login(authUrl, credentials, REMEMBER_ME.get(false), customHeaders).pipe(map(response => {\n          if ('claims' in response) {\n            return response;\n          } else {\n            return this.cleanUp(response);\n          }\n        }));\n      } else {\n        const silentLoginNotPossible = {\n          status: -1,\n          data: {\n            code: 'UNKNOWN'\n          }\n        };\n        console.warn('silent login not possible', silentLoginNotPossible);\n        return of(silentLoginNotPossible);\n      }\n    }\n    pinCodeLogin(authUrl, pinCode) {\n      const headers = {\n        'Authorization-MFA': 'pincode=' + pinCode\n      };\n      return lastValueFrom(this.trySilentLogin(authUrl, headers));\n    }\n    authTimedOut() {\n      REFRESH_TOKEN.delete();\n    }\n    logout(user) {\n      const authorization = this.appContext.requestParams.get('authorizationHeader');\n      let headers = {};\n      if (this.utils.exists(authorization)) {\n        headers = new HttpHeaders({\n          Authorization: authorization\n        });\n      }\n      this.clearAllTokens();\n      if (user && user.links && user.links.logout) {\n        return this.http.delete(user.links.logout, {\n          headers\n        });\n      } else {\n        return of({});\n      }\n    }\n    changePassword(username, changePasswordUrl, currentPassword, newPassword) {\n      const body = {\n        password: newPassword\n      };\n      const options = {\n        withCredentials: true,\n        headers: Object.assign(Object.assign({}, this.buildAuthHeader({\n          username: username,\n          password: currentPassword\n        })), {\n          'Content-Type': 'application/json'\n        }),\n        context: new HttpContext().set(ERROR_PASS_THROUGH, true)\n      };\n      return this.http.post(changePasswordUrl, body, options).pipe(tap(this.updateStoredAuthDetails));\n    }\n    clearCurrentAuthToken() {\n      return this.deleteAuthHeader();\n    }\n    clearAllTokens() {\n      this.deleteAuthHeader();\n      this.clearStoredTokens();\n    }\n    oidcLogin(authUrl, oidcJwt) {\n      const config = {\n        withCredentials: true,\n        headers: new HttpHeaders().set('Authorization', 'Bearer ' + oidcJwt),\n        context: new HttpContext().set(ERROR_PASS_THROUGH, true)\n      };\n      REMEMBER_ME.set(true);\n      return this.http.get(authUrl, config).pipe(tap(this.updateStoredAuthDetails), map(response => ({\n        claims: this.jwtHelper.decodeToken(response.token),\n        organizations: response.customClaims.organizations,\n        canChangePassword: false,\n        logoutUrl: response.links.logout\n      })), catchError(err => {\n        if (err instanceof HttpErrorResponse) {\n          return throwError(() => ({\n            status: err.status,\n            data: {\n              code: 'BAD_CREDENTIALS'\n            }\n          }));\n        } else throw err;\n      }));\n    }\n    setPinCode(url, pinCode) {\n      const body = {\n        pinCode: pinCode\n      };\n      const config = {\n        context: new HttpContext().set(ERROR_PASS_THROUGH, true),\n        headers: new HttpHeaders({\n          'Content-Type': 'application/json'\n        })\n      };\n      return lastValueFrom(this.http.post(url, body, config).pipe(catchError(err => {\n        if (err instanceof HttpErrorResponse && err.status in [401, 403]) console.error('User is not authorized to call setPinCode()');\n        return throwError(() => err);\n      })));\n    }\n    tryGetRefreshToken() {\n      if (REFRESH_TOKEN.get()) {\n        return REFRESH_TOKEN.get();\n      }\n      if (AUTO_LOGIN_TOKEN.get()) {\n        return AUTO_LOGIN_TOKEN.get();\n      }\n      return null;\n    }\n    clearStoredTokens() {\n      REFRESH_TOKEN.delete();\n      AUTO_LOGIN_TOKEN.delete();\n      REMEMBER_ME.delete();\n    }\n    setCanChangePassword(canChange) {\n      CAN_CHANGE_PASSWORD.set(canChange);\n    }\n    createCredentials(jwt, customClaims, canChangePassword, logoutUrl) {\n      const claims = this.jwtHelper.decodeToken(jwt);\n      return {\n        claims: claims,\n        organizations: customClaims.organizations,\n        canChangePassword: canChangePassword,\n        logoutUrl: logoutUrl !== null ? logoutUrl : undefined\n      };\n    }\n    buildAuthHeader(credentials) {\n      let authorization = undefined;\n      if ('username' in credentials) {\n        const encodedCredentials = btoa(`${credentials.username}:${credentials.password}`);\n        authorization = `Basic ${encodedCredentials}`;\n      } else if ('token' in credentials) {\n        authorization = `${credentials.type} ${credentials.token}`;\n      }\n      return authorization !== undefined ? {\n        authorization\n      } : undefined;\n    }\n    deleteAuthHeader() {\n      if (this.appContext.requestParams.containsKey('authorizationHeader')) {\n        this.appContext.requestParams.getAndClear('authorizationHeader');\n      }\n    }\n    deletePatientAuthHeader() {\n      if (this.appContext.requestParams.containsKey('patientAuthorizationHeader')) {\n        this.appContext.requestParams.getAndClear('patientAuthorizationHeader');\n      }\n    }\n    wrapError(response) {\n      const status = response.status;\n      if (status === 401 && this.utils.exists(response.error.errors)) {\n        const errors = response.error.errors;\n        const reason = errors[0].error;\n        const field = errors[0].field;\n        if (field.toLowerCase() === 'authorization-mfa') {\n          return {\n            status: status,\n            data: {\n              code: 'BAD_MFA_CREDENTIALS'\n            }\n          };\n        } else {\n          switch (reason) {\n            case 'invalid':\n              return {\n                status: status,\n                data: {\n                  code: 'BAD_CREDENTIALS'\n                }\n              };\n            case 'locked':\n              return {\n                status: status,\n                data: {\n                  code: 'ACCOUNT_LOCKED'\n                }\n              };\n            case 'inactive':\n              return {\n                status: status,\n                data: {\n                  code: 'USER_INACTIVE'\n                }\n              };\n            case 'expired':\n              return {\n                status: status,\n                data: {\n                  code: 'PASSWORD_EXPIRED'\n                }\n              };\n            case 'pincode_required':\n              return {\n                status: status,\n                data: {\n                  code: 'PINCODE_REQUIRED'\n                }\n              };\n            default:\n              return {\n                status: status,\n                data: {\n                  code: 'UNKNOWN'\n                }\n              };\n          }\n        }\n      } else {\n        return {\n          status: status,\n          data: {\n            code: 'UNKNOWN'\n          }\n        };\n      }\n    }\n    cleanUp(response) {\n      const status = response.status;\n      const data = response.data;\n      switch (status) {\n        case 401:\n          {\n            switch (data.code) {\n              case 'PINCODE_REQUIRED':\n              case 'BAD_MFA_CREDENTIALS':\n              case 'ACCOUNT_LOCKED':\n                return {\n                  status,\n                  data\n                };\n              default:\n                this.clearStoredTokens();\n                // we must return bad credentials here because we need to go to\n                // the login screen to get the username, which has been\n                // cleared...\n                return {\n                  status,\n                  data: Object.assign(Object.assign({}, data), {\n                    code: 'BAD_CREDENTIALS'\n                  })\n                };\n            }\n          }\n        default:\n          return response;\n      }\n    }\n    isJWT(candidate) {\n      return typeof candidate === 'object' && candidate !== null && ['claims', 'organizations', 'canChangePassword'].every(property => property in candidate);\n    }\n  }\n  AuthenticationService.ɵfac = function AuthenticationService_Factory(t) {\n    return new (t || AuthenticationService)(i0.ɵɵinject(i1.StatePassingService), i0.ɵɵinject(i2.HttpClient), i0.ɵɵinject(i3.Utils));\n  };\n  AuthenticationService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthenticationService,\n    factory: AuthenticationService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthenticationService;\n})();","map":null,"metadata":{},"sourceType":"module"}
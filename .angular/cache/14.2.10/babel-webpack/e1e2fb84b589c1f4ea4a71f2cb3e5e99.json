{"ast":null,"code":"import { BloodSugarConstraint } from '@app/types/model.type';\nimport { MeasurementTypeName } from '@app/types/measurement-types.type';\nimport * as i0 from \"@angular/core\";\nexport let TablesService = /*#__PURE__*/(() => {\n  class TablesService {\n    constructor() {\n      this.createTable = measurementsResult => {\n        if (measurementsResult.measurements.length == 0 || measurementsResult.type === MeasurementTypeName.BLOOD_SUGAR || measurementsResult.type === MeasurementTypeName.BLOOD_SUGAR_MG_DL) {\n          return undefined;\n        } else if (measurementsResult.type === MeasurementTypeName.SPIROMETRY) {\n          const tableOptions = this.createMultiColumnTableOptions(measurementsResult);\n          const tableData = this.createSpirometryTableData(measurementsResult);\n          return {\n            kind: 'multiColumn',\n            options: tableOptions,\n            data: tableData\n          };\n        } else {\n          const tableOptions = this.createSingleColumnTableOptions(measurementsResult);\n          const tableData = this.createDefaultTableData(measurementsResult);\n          return {\n            kind: 'singleColumn',\n            options: tableOptions,\n            data: tableData\n          };\n        }\n      };\n      this.createSingleColumnTableOptions = measurementsResult => {\n        const dateFormat = measurementsResult.type === MeasurementTypeName.DAILY_STEPS || measurementsResult.type === MeasurementTypeName.DAILY_STEPS_WEEKLY_AVERAGE ? 'll' : 'lll';\n        const unit = measurementsResult.unit;\n        return {\n          dateFormat: dateFormat,\n          numberFormat: measurementsResult.type ? this.getNumberFormat(measurementsResult.type) : undefined,\n          unit: unit\n        };\n      };\n      this.getNumberFormat = measurementTypeName => {\n        const floatTypes = [MeasurementTypeName.BLOOD_SUGAR, MeasurementTypeName.BLOOD_SUGAR_MG_DL, MeasurementTypeName.CRP, MeasurementTypeName.DURATION_HOURS, MeasurementTypeName.FEF25_75, MeasurementTypeName.FEV1, MeasurementTypeName.FEV6, MeasurementTypeName.HEMOGLOBIN, MeasurementTypeName.PAIN_SCALE, MeasurementTypeName.SPIROMETRY, MeasurementTypeName.TEMPERATURE, MeasurementTypeName.TEMPERATURE_FAHRENHEIT, MeasurementTypeName.WEIGHT, MeasurementTypeName.WEIGHT_POUND];\n        const noFormat = [MeasurementTypeName.BLOOD_PRESSURE, MeasurementTypeName.GLUCOSE_IN_URINE, MeasurementTypeName.PROTEIN_IN_URINE, MeasurementTypeName.URINE_BLOOD, MeasurementTypeName.URINE_LEUKOCYTES, MeasurementTypeName.URINE_NITRITE];\n        if (noFormat.indexOf(measurementTypeName) >= 0) {\n          return undefined;\n        } else if (floatTypes.indexOf(measurementTypeName) >= 0) {\n          return '1.1-1';\n        } else {\n          return '1.0-0';\n        }\n      };\n      this.createDefaultTableData = measurementsResult => {\n        if (measurementsResult.type === MeasurementTypeName.BLOOD_PRESSURE) {\n          return measurementsResult.measurements.map(measurement => {\n            const measurementValue = measurement.measurement;\n            const pulseStr = measurementValue.pulse ? `, ${measurementValue.pulse}` : '';\n            const bloodPressureValue = measurementValue.systolic + '/' + measurementValue.diastolic + pulseStr;\n            return {\n              kind: 'singleValue',\n              timestamp: measurement.timestamp,\n              value: bloodPressureValue,\n              comment: measurement.comment,\n              severity: measurement.severity,\n              constraint: undefined\n            };\n          });\n        } else if (measurementsResult.type == MeasurementTypeName.CRP) {\n          return measurementsResult.measurements.map(measurement => {\n            const measurementValue = measurement.measurement;\n            let updatedValue;\n            if (0 <= measurementValue.value && measurementValue.value < 5) {\n              updatedValue = '< 5';\n            } else {\n              updatedValue = measurementValue.value;\n            }\n            return {\n              kind: 'singleValue',\n              timestamp: measurement.timestamp,\n              value: updatedValue,\n              comment: measurement.comment,\n              severity: measurement.severity,\n              constraint: undefined\n            };\n          });\n        } else {\n          return measurementsResult.measurements.map(measurement => {\n            return {\n              kind: 'singleValue',\n              timestamp: measurement.timestamp,\n              value: measurement.measurement.value,\n              comment: measurement.comment,\n              severity: measurement.severity,\n              constraint: undefined\n            };\n          });\n        }\n      };\n      this.createMultiColumnTableOptions = _measurementsResult => {\n        const dateFormat = 'lll';\n        const units = ['fev1[L]', 'fev6[L]', 'fev1[%]', 'fev6[%]'];\n        const numberFormats = ['1.1-1', '1.1-1', '1.0-0', '1.0-0'];\n        return {\n          dateFormat: dateFormat,\n          numberFormats: numberFormats,\n          units: units\n        };\n      };\n      this.createSpirometryTableData = measurementsResult => {\n        return measurementsResult.measurements.map(measurement => {\n          const measurementValue = measurement.measurement;\n          const orDefaultValue = (measurementValue, key) => {\n            const defaultValueSeverityPair = {\n              value: undefined,\n              unit: '',\n              severity: undefined\n            };\n            return measurementValue[key] ? measurementValue[key] : defaultValueSeverityPair;\n          };\n          return {\n            kind: 'multiValue',\n            timestamp: measurement.timestamp,\n            comment: measurement.comment,\n            values: [orDefaultValue(measurementValue, 'fev1'), orDefaultValue(measurementValue, 'fev6'), orDefaultValue(measurementValue, 'fev1%'), orDefaultValue(measurementValue, 'fev6%')]\n          };\n        });\n      };\n      this.createStandardDayTable = measurementsResult => {\n        if (measurementsResult.measurements.length == 0 || measurementsResult.type !== MeasurementTypeName.BLOOD_SUGAR && measurementsResult.type !== MeasurementTypeName.BLOOD_SUGAR_MG_DL) {\n          return undefined;\n        } else {\n          const measurementDates = this.createMeasurementDates(measurementsResult.measurements);\n          return {\n            measurementDates: measurementDates\n          };\n        }\n      };\n      /**\r\n       * Partitions the measurements by date and returns a list of `MeasurementDate`.\r\n       */\n      this.createMeasurementDates = measurements => {\n        const partitions = new Map();\n        const getDateWithoutTime = timestamp => {\n          const date = new Date(timestamp);\n          const year = date.getFullYear();\n          let month;\n          if (date.getMonth() + 1 > 9) {\n            month = date.getMonth() + 1;\n          } else {\n            month = `0${date.getMonth() + 1}`;\n          }\n          const day = date.getDate() > 9 ? date.getDate().toString() : `0${date.getDate()}`;\n          return `${year}-${month}-${day}`;\n        };\n        measurements.forEach(measurement => {\n          const dateKey = getDateWithoutTime(measurement.timestamp);\n          measurement.measurement.value = Math.round(measurement.measurement.value * 10) / 10;\n          if (!partitions.hasOwnProperty(dateKey)) {\n            partitions[dateKey] = [];\n          }\n          partitions[dateKey].push(measurement);\n        });\n        const measurementDates = Object.entries(partitions).map(([dateKey, measurements]) => this.createMeasurementDate(dateKey, measurements));\n        return measurementDates;\n      };\n      /**\r\n       * Partitions the measurements by time of day and returns a `MeasurementDate`.\r\n       */\n      this.createMeasurementDate = (date, measurements) => {\n        const assignToPartition = (partitionedMeasurement, tableDatum, hour) => {\n          if (0 <= hour && hour < 5) {\n            partitionedMeasurement.night.push(tableDatum);\n          } else if (5 <= hour && hour < 11) {\n            partitionedMeasurement.morning.push(tableDatum);\n          } else if (11 <= hour && hour < 17) {\n            partitionedMeasurement.afternoon.push(tableDatum);\n          } else {\n            partitionedMeasurement.evening.push(tableDatum);\n          }\n        };\n        const partitionedMeasurement = {\n          date: date,\n          night: [],\n          morning: [],\n          afternoon: [],\n          evening: []\n        };\n        const determineConstraint = measurement => {\n          if (measurement.isAfterMeal) {\n            return BloodSugarConstraint.IS_AFTER_MEAL;\n          } else if (measurement.isBeforeMeal) {\n            return BloodSugarConstraint.IS_BEFORE_MEAL;\n          } else if (measurement.isFasting) {\n            return BloodSugarConstraint.IS_FASTING;\n          } else {\n            return BloodSugarConstraint.NONE;\n          }\n        };\n        measurements.forEach(measurement => {\n          const dateHours = new Date(measurement.timestamp).getHours();\n          const tableDatum = {\n            kind: 'singleValue',\n            timestamp: measurement.timestamp,\n            value: measurement.measurement.value,\n            comment: measurement.comment,\n            severity: measurement.severity,\n            constraint: determineConstraint(measurement.measurement)\n          };\n          assignToPartition(partitionedMeasurement, tableDatum, dateHours);\n        });\n        return partitionedMeasurement;\n      };\n    }\n  }\n  TablesService.ɵfac = function TablesService_Factory(t) {\n    return new (t || TablesService)();\n  };\n  TablesService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TablesService,\n    factory: TablesService.ɵfac,\n    providedIn: 'root'\n  });\n  return TablesService;\n})();","map":null,"metadata":{},"sourceType":"module"}
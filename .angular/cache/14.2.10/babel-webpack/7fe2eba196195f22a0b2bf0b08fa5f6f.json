{"ast":null,"code":"import { EventEmitter } from \"@angular/core\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngx-translate/core\";\nexport let TimerComponent = /*#__PURE__*/(() => {\n  class TimerComponent {\n    constructor(translate) {\n      this.translate = translate;\n      this.count = undefined;\n      this.countUp = undefined;\n      this.countTime = undefined;\n      this.onTimerStopped = undefined;\n      this.timerStoppedChange = new EventEmitter();\n      this.interval = 1000;\n      this.stopTicking = undefined;\n      this.stopWatching = undefined;\n      this.timerDescription = undefined;\n      this.stopTimer = () => {\n        this.count = this.countUp === true ? 0 : this.countTime;\n        if (this.stopTicking) {\n          clearInterval(this.stopTicking);\n          this.stopTicking = undefined;\n        }\n      };\n      this.nextNode = () => {\n        this.stopTimer();\n        this.timerStoppedChange.emit(undefined);\n      };\n      this.updateDescription = () => {\n        let descriptionLeft = this.translate.instant(\"DELAY_NODE_DESCRIPTION_LEFT_DOWN\");\n        const descriptionCenter = this.translate.instant(\"DELAY_NODE_DESCRIPTION_CENTER\");\n        const descriptionRight = this.translate.instant(\"DELAY_NODE_DESCRIPTION_RIGHT\");\n        if (this.countUp === true) {\n          descriptionLeft = this.translate.instant(\"DELAY_NODE_DESCRIPTION_LEFT_UP\");\n        }\n        this.timerDescription = descriptionLeft + \" \" + this.count + \" \" + descriptionCenter + \" \" + this.countTime + \" \" + descriptionRight;\n      };\n      this.tick = () => {\n        if (this.countUp === true) {\n          this.count++;\n          this.updateDescription();\n          if (this.count >= this.countTime) {\n            return this.nextNode();\n          }\n        } else {\n          this.count--;\n          this.updateDescription();\n          if (this.count <= 0) {\n            return this.nextNode();\n          }\n        }\n        return undefined;\n      };\n    }\n    ngOnChanges(changes) {\n      if (changes.count.currentValue === undefined) {\n        this.stopTimer();\n        this.stopWatching();\n      }\n      this.updateDescription();\n      const wrapTick = () => this.tick();\n      this.stopTicking = setInterval(wrapTick, this.interval, this.countTime);\n    }\n    ngOnDestroy() {\n      console.debug('Timer component onDestroy');\n      if (this.stopTicking) {\n        clearInterval(this.stopTicking);\n        this.stopTicking = undefined;\n      }\n    }\n  }\n  TimerComponent.ɵfac = function TimerComponent_Factory(t) {\n    return new (t || TimerComponent)(i0.ɵɵdirectiveInject(i1.TranslateService));\n  };\n  TimerComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: TimerComponent,\n    selectors: [[\"timer\"]],\n    inputs: {\n      count: \"count\",\n      countUp: \"countUp\",\n      countTime: \"countTime\",\n      onTimerStopped: \"onTimerStopped\"\n    },\n    outputs: {\n      timerStoppedChange: \"timerStoppedChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 1,\n    consts: [[1, \"center-div\"], [1, \"line-wrap\", \"text-element\"]],\n    template: function TimerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"h2\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.timerDescription);\n      }\n    }\n  });\n  return TimerComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}
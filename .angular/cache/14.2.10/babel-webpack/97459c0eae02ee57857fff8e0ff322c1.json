{"ast":null,"code":"import { HttpContext, HttpHeaders } from '@angular/common/http';\nimport { MessageThread, ThreadMessagesResult, ThreadRef, ThreadsResult } from 'src/app/types/messages.type';\nimport { ERROR_PASS_THROUGH, SILENT_REQUEST } from '@app/interceptors/interceptor';\nimport { lastValueFrom, map, Observable, of, mergeMap, from, toArray } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"../util-services/util.service\";\nexport let MessageThreadsService = /*#__PURE__*/(() => {\n  class MessageThreadsService {\n    constructor(http, utils) {\n      this.http = http;\n      this.utils = utils;\n    }\n    list(user, errorPassThrough) {\n      if (!this.utils.exists(user.links.threads)) {\n        throw new TypeError('User object does not contain a link relation to messageThreads');\n      }\n      return lastValueFrom(this.http.get(user.links.threads, {\n        context: new HttpContext().set(SILENT_REQUEST, true).set(ERROR_PASS_THROUGH, errorPassThrough)\n      }));\n    }\n    get(messageThreadRef) {\n      return lastValueFrom(this.http.get(messageThreadRef.links.thread));\n    }\n    markAsRead(thread) {\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return lastValueFrom(this.http.post(thread.links.thread + '/read', '', {\n        context: new HttpContext().set(SILENT_REQUEST, true),\n        headers\n      }));\n    }\n    getMessages(thread) {\n      return lastValueFrom(this.http.get(thread.links.messages).pipe(map(response => response.results)));\n    }\n    postAttachment(user, file) {\n      if (!file || !this.utils.exists(user.links.attachments)) {\n        return of();\n      }\n      const headers = new HttpHeaders({\n        'Content-Type': file.type\n      });\n      return this.http.post(user.links.attachments, file, {\n        headers: headers,\n        observe: 'response'\n      }).pipe(map(response => {\n        const location = response.headers.get('location');\n        if (!this.utils.exists(location)) throw new Error('Unable to submit attachment');\n        return location;\n      }));\n    }\n    deleteAttachment(url) {\n      return this.http.delete(url);\n    }\n    getAttachmentDataUrl(url) {\n      return this.http.get(url, {\n        responseType: 'blob',\n        context: new HttpContext().set(SILENT_REQUEST, true).set(ERROR_PASS_THROUGH, true)\n      }).pipe(mergeMap(blob => {\n        const reader = new FileReader();\n        return new Observable(subscriber => {\n          reader.onloadend;\n          reader.onload = () => {\n            subscriber.next(reader.result);\n            subscriber.complete();\n          };\n          reader.readAsDataURL(blob);\n        });\n      }));\n    }\n    create(user, departmentUrl, body, files) {\n      const messagesUrl = user.links.messages;\n      if (!this.utils.exists(messagesUrl)) {\n        throw new TypeError(`User does not have any messages`);\n      }\n      return from(files).pipe(mergeMap(file => this.postAttachment(user, file)), toArray(), mergeMap(fileUrls => {\n        const message = {\n          body,\n          sender: {\n            name: `${user.firstName} ${user.lastName}`,\n            type: 'patient'\n          },\n          links: {\n            organization: departmentUrl,\n            patient: user.links.self,\n            attachments: fileUrls\n          }\n        };\n        return this.postMessage(message, messagesUrl);\n      }));\n    }\n    postMessage(message, messagesUrl) {\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.post(messagesUrl, message, {\n        context: new HttpContext().set(ERROR_PASS_THROUGH, true),\n        headers\n      }).pipe(map(() => {\n        return;\n      }));\n    }\n  }\n  MessageThreadsService.ɵfac = function MessageThreadsService_Factory(t) {\n    return new (t || MessageThreadsService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.Utils));\n  };\n  MessageThreadsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: MessageThreadsService,\n    factory: MessageThreadsService.ɵfac,\n    providedIn: 'root'\n  });\n  return MessageThreadsService;\n})();","map":null,"metadata":{},"sourceType":"module"}
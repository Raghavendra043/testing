{"ast":null,"code":"import { RepresentationType } from \"src/app/types/parser.type\";\nimport { exists } from \"src/app/components/questionnaire-nodes/node-form-utils\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./parser-utils.service\";\nimport * as i2 from \"../native-services/native.service\";\nimport * as i3 from \"../device-listener-services/device-listener.service\";\nexport let DeviceNodeParserService = /*#__PURE__*/(() => {\n  class DeviceNodeParserService {\n    constructor(parserUtils, native, deviceListenerService) {\n      this.parserUtils = parserUtils;\n      this.native = native;\n      this.deviceListenerService = deviceListenerService;\n      this.getMeasurementTypeNames = meterType => {\n        const accumulateNames = (acc, measurementType) => {\n          return acc.concat(\n          // @ts-ignore\n          measurementType.kind === \"multiple\" ? measurementType.values : [measurementType.value]);\n        };\n        const measurementTypes = meterType.measurementTypes.reduce(accumulateNames, []);\n        return measurementTypes;\n      };\n      this.generateValidate = measurementTypeNames => {\n        return scope => {\n          const nodeModel = scope.representation.nodeModel;\n          const checkMeasurementValues = (acc, measurementTypeName) => acc && exists(nodeModel[measurementTypeName]);\n          const checkEnteredValues = measurementTypeNames => measurementTypeNames.reduce(checkMeasurementValues, true);\n          return checkEnteredValues(measurementTypeNames);\n        };\n      };\n      this.generateClickAction = (measurementTypeNames, outputMapper, node) => {\n        return scope => {\n          let measurements = measurementTypeNames.concat([\"origin\"]);\n          if (exists(outputMapper)) {\n            measurements = outputMapper(measurements, scope.representation.nodeModel);\n          }\n          this.parserUtils.addMeasurementCommentToOutput(scope.outputModel, scope.representation.nodeModel, node);\n          this.parserUtils.addMeasurementsToOutput(scope.outputModel, scope.representation.nodeModel, node, measurements);\n        };\n      };\n      this.generateRepresentationGenerator = (meterType, deviceNodeType) => {\n        const outputMapper = deviceNodeType.outputMapper;\n        const measurementTypeNames = this.getMeasurementTypeNames(meterType);\n        const generateRepresentation = (node, nodeModel) => {\n          const leftButton = {\n            show: true,\n            text: \"SKIP\",\n            nextNodeId: node.nextFail\n          };\n          const rightButton = {\n            show: true,\n            text: \"NEXT\",\n            nextNodeId: node.next,\n            validate: this.generateValidate(measurementTypeNames),\n            click: this.generateClickAction(measurementTypeNames, outputMapper, node)\n          };\n          const representation = {\n            kind: RepresentationType.NODE,\n            nodeModel: nodeModel,\n            leftButton: leftButton,\n            rightButton: rightButton\n          };\n          return representation;\n        };\n        return generateRepresentation;\n      };\n      this.create = deviceNodeType => {\n        const meterType = deviceNodeType.meterType;\n        const generateRepresentation = this.generateRepresentationGenerator(meterType, deviceNodeType);\n        return node => {\n          const infoText = deviceNodeType.infoText;\n          const nodeModel = {\n            nodeId: node.nodeName,\n            heading: node.text,\n            progress: 0,\n            info: exists(infoText) ? infoText : \"CONNECTING\"\n          };\n          if (\"comment\" in node) {\n            nodeModel.comment = node.comment;\n          }\n          const eventListener = this.deviceListenerService.create(nodeModel, meterType);\n          const nativeEventCallback = message => {\n            const expectedMeterTypeName = deviceNodeType.meterType.name;\n            if (message.meterType !== expectedMeterTypeName) {\n              return;\n            }\n            eventListener(message.event);\n          };\n          const parameters = {};\n          meterType.parameters.forEach(parameter => {\n            if (parameter in node) {\n              const dynamicNode = node;\n              parameters[parameter] = dynamicNode[parameter];\n            }\n          });\n          this.native.subscribeToMultipleMessages(\"deviceMeasurementResponse\", nativeEventCallback);\n          const listenerAdded = this.native.addDeviceListener(meterType.name, parameters);\n          if (!listenerAdded) {\n            const error = new Error(`Could not add device listener for ${meterType.name}`);\n            throw error;\n          }\n          const representation = generateRepresentation(node, nodeModel);\n          if (\"helpMenu\" in representation) {\n            this.parserUtils.addHelpMenu(node, representation);\n          }\n          return representation;\n        };\n      };\n    }\n  }\n  DeviceNodeParserService.ɵfac = function DeviceNodeParserService_Factory(t) {\n    return new (t || DeviceNodeParserService)(i0.ɵɵinject(i1.ParserUtilsService), i0.ɵɵinject(i2.NativeService), i0.ɵɵinject(i3.DeviceListenerService));\n  };\n  DeviceNodeParserService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: DeviceNodeParserService,\n    factory: DeviceNodeParserService.ɵfac,\n    providedIn: \"root\"\n  });\n  return DeviceNodeParserService;\n})();","map":null,"metadata":{},"sourceType":"module"}